read input files that end in .tk, prob verify that it ends in .tk
for each line: 

enum mode = code, data //maybe just an input


if starts with a tab character{

    //process according to the enum mode (or maybe just int mode)
}else if starts with a semi colon{

//just ignore that line because it's a comment

}else if starts with a colon{

    is a label, then record the address (derived from how many )
}else{
    throw an error sicne hte line is invalid
}

how tf do we exapand some macros such as ld and xor??? 
ahh, kinda need to hardcode a specific replacement for each...

then once the direct replacement is completed, then we do another interpreter that
kinda acts as a string parser from last prog... --> somehow converts to binary...

//need to find a way to parse the args of the instruction

probably split by the tab character, then parse out the action, replace any number of spaces with a single space -- like that regex pattern I once used...

once you parse out all the tab characters, if in the .code mode, then you can append it to a code string builder, and vise versa for .data
print .code
then, print out the string builder code
then print new line, then print .data
then print out the .data code

append - ("\n\t%s", instruction)
for(param in params){
    append the param with spaces and stuff (but if it's the last param, then don't add a space)
}
//todo for validation: ensure that registers always begin with an r and have a num 0-31, other number need to be in-range of correct range


//Can ONLY merge consecutive segments

stuff to replace: 
clr r0 = xor r0, r0, r0 //since xor of anything with itself is zero and storing it back in itself

how to convert ld rd, L //which loads the unsigned literal (so must be positive), and loads it into the register rd
xor rd, rd, rd //to clear the register
addi rd, (L >> 52) //add L shifted 52 (so only the right 12 bits are exposed), probably actually eval the thing and just put the final result of the expansion in the expanded intermediate
shftli rd, 12 //shift left by 12 so that there's room for the next 12

