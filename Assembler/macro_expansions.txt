TINKER ASSEMBLER - MACRO EXPANSIONS
====================================

This document details all macros and their proper expansions into
base Tinker assembly instructions.

--------------------------------------------------------------------------------
1. halt
--------------------------------------------------------------------------------
   Syntax:    halt
   Function:  Stops the simulation/program execution

   Expansion: priv r0, r0, r0, 0x0
              (or equivalently: trap 0x0)

   Notes:     Uses the privileged instruction with L=0x0 (halt function)

--------------------------------------------------------------------------------
2. clr rd
--------------------------------------------------------------------------------
   Syntax:    clr rd
   Function:  Sets register rd to zero

   Expansion: xor rd, rd, rd

   Example:   clr r0  -->  xor r0, r0, r0

   Notes:     XORing a register with itself always produces zero

--------------------------------------------------------------------------------
3. ld rd, L
--------------------------------------------------------------------------------
   Syntax:    ld rd, L
   Function:  Loads a 64-bit literal value L into register rd

   Expansion: Requires multiple instructions since mov rd, L only sets
              bits 52:63 (12 bits at a time)

   Full expansion for 64-bit value:
              xor rd, rd, rd           ; clear the register first
              mov rd, L[63:52]         ; load highest 12 bits
              shftli rd, 12            ; shift left 12 bits
              mov rd, L[51:40]         ; load next 12 bits
              shftli rd, 12            ; shift left
              mov rd, L[39:28]         ; load next 12 bits
              shftli rd, 12            ; shift left
              mov rd, L[27:16]         ; load next 12 bits
              shftli rd, 12            ; shift left
              mov rd, L[15:4]          ; load next 12 bits
              shftli rd, 4             ; shift left 4 bits
              mov rd, L[3:0]           ; load final 4 bits (zero-padded to 12)

   Notes:     - L can be a numeric literal or a label (e.g., :L1)
              - When L is a label, it gets resolved to the address
              - The assembler should optimize based on actual value size

--------------------------------------------------------------------------------
4. ld rd, :label
--------------------------------------------------------------------------------
   Syntax:    ld rd, :label
   Function:  Loads the address of a label into register rd

   Expansion: Same as ld rd, L where L = resolved address of the label

   Example:   ld r5, :L1  -->  (after resolving :L1 to address 0x100c)
                               ld r5, 0x100c
                           -->  (full expansion as above)

   Notes:     This loads the ADDRESS, not the content at that address

--------------------------------------------------------------------------------
5. in rd, rs
--------------------------------------------------------------------------------
   Syntax:    in rd, rs
   Function:  Reads from input port specified by rs, stores in rd
              rd <- Input[rs]

   Expansion: priv rd, rs, r0, 0x3

   Example:   in r1, r2  -->  priv r1, r2, r0, 0x3

   Notes:     Port 0 = keyboard, Port 1 = console output

--------------------------------------------------------------------------------
6. out rd, rs
--------------------------------------------------------------------------------
   Syntax:    out rd, rs
   Function:  Writes value in rs to output port specified by rd
              Output[rd] <- rs

   Expansion: priv rd, rs, r0, 0x4

   Example:   out r1, r2  -->  priv r1, r2, r0, 0x4

   Notes:     Port 0 = keyboard, Port 1 = console output

--------------------------------------------------------------------------------
7. out rd (single argument form)
--------------------------------------------------------------------------------
   Syntax:    out rd
   Function:  Outputs value in rd to console (port 1)

   Expansion: (requires temporary register, e.g., using convention)
              mov rT, 1                ; set temp register to port 1
              priv rT, rd, r0, 0x4     ; output rd to port 1

   Alternative (if r0 is guaranteed zero and using r1 as temp):
              xor rT, rT, rT
              addi rT, 1
              priv rT, rd, r0, 0x4

   Notes:     Implementation may vary; console is port 1 by convention

--------------------------------------------------------------------------------
8. push rd
--------------------------------------------------------------------------------
   Syntax:    push rd
   Function:  Pushes the value in rd onto the stack

   Expansion: subi r31, 8              ; decrement stack pointer by 8 bytes
              mov (r31)(0), rd         ; store rd at new stack top

   Example:   push r5  -->  subi r31, 8
                            mov (r31)(0), r5

   Notes:     r31 is the stack pointer by convention
              Stack grows downward (toward lower addresses)

--------------------------------------------------------------------------------
9. pop rd
--------------------------------------------------------------------------------
   Syntax:    pop rd
   Function:  Pops the top value from stack into rd

   Expansion: mov rd, (r31)(0)         ; load value from stack top into rd
              addi r31, 8              ; increment stack pointer by 8 bytes

   Example:   pop r5  -->  mov r5, (r31)(0)
                           addi r31, 8

   Notes:     r31 is the stack pointer by convention

--------------------------------------------------------------------------------
SUMMARY TABLE
--------------------------------------------------------------------------------

Macro               | Expansion
--------------------|----------------------------------------------------------
halt                | priv r0, r0, r0, 0x0
clr rd              | xor rd, rd, rd
ld rd, L            | (series of mov and shftli to load 64-bit value)
ld rd, :label       | ld rd, <resolved_address>
in rd, rs           | priv rd, rs, r0, 0x3
out rd, rs          | priv rd, rs, r0, 0x4
push rd             | subi r31, 8; mov (r31)(0), rd
pop rd              | mov rd, (r31)(0); addi r31, 8

--------------------------------------------------------------------------------
NOTES ON IMPLEMENTATION
--------------------------------------------------------------------------------

1. The assembler should perform TWO PASSES:
   - Pass 1: Parse input, expand macros, identify labels, compute addresses
   - Pass 2: Generate machine code from expanded instructions

2. Labels (starting with :) are resolved to actual memory addresses in Pass 1

3. The intermediate file (after Pass 1) should contain only base instructions
   with all macros fully expanded and labels resolved to addresses

4. Register r31 is conventionally used as the stack pointer

5. Port conventions for I/O:
   - Port 0: Keyboard input
   - Port 1: Console output
